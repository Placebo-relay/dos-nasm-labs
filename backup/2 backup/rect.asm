; Listing 3.5 rect.asm
; Программа отрисовывает в середине экрана
; квадраты, перебирая при этом 15 стандартных цветов

org 0x100

mov ah, 0x00 ; Функция BIOS выбора графического режима
mov al, 0x13 ; Графический режим 320x200, 256 цветов
int 0x10 ; Вызов BIOS

mov cx, 10 ; Координата левого верхнего угла первого квадрата
mov dx, 80 ; Координата, определяющая позицию строки с квадратами
mov si, 15 ; Размер квадратов
mov al, 15 ; Цвет первого квадрата

plotting:

call PlotSquare ; Отрисовываем квадрат

add cx, 20 ; Передвигаемся по горизонтали
dec al ; Изменяем цвет, а также декрементируем счетчик

jnz plotting ; Переход, если не достигли нуля

nokey:
mov ah, 0x01 ; Функция чтения клавиатуры
int 0x16 ; Вызов BIOS
jz nokey ; Переходим, если ничего не прочитано, т.е. находимся здесь, пока не будет нажата клавиша

mov ah, 0x00 ; Функция BIOS выбора графического режима
mov al, 0x03 ; Текстовый режим 80x25, 16 цветов
int 0x10 ; Вызов BIOS

ret

PlotSquare:

; Вход:
; cx хранит горизонтальную координату левого верхнего угла
; dx хранит вертикальную координату левого верхнего угла
; si хранит размер стороны квадрата
; al хранит цвет

push si ; Запоминаем значения регистров
push cx
push dx
push ax
push di

mov di, si ; В di будет храниться ширина
mov ah, 0x0c ; Функция BIOS отображения точки

.plot:
; Здесь в одном цикле отрисовываются все точки квадрата.
; Начальное значение счетчика si равно длине стороны,
; координаты точек записываются в пару регистров cx, dx.
; Для понимания порядка отрисовки точек сделайте рисунок на бумаге.

add cx, si
int 0x10 ; Вызов BIOS

add dx, di
int 0x10 ; Вызов BIOS

sub cx, si
sub dx, di
add dx, si
int 0x10 ; Вызов BIOS

add cx, di
int 0x10 ; Вызов BIOS

sub cx, di
sub dx, si

dec si ; Декрементируем счетчик
jnz .plot ; Переход, если не все точки отрисованы

int 0x10 ; Отрисовываем последнюю точку

pop di ; Восстанавливаем значения регистров
pop ax ; Внимание! Восстановление идет в порядке,
pop dx ; обратном тому, в котором регистры
pop cx ; были помещены в стек.
pop si

ret